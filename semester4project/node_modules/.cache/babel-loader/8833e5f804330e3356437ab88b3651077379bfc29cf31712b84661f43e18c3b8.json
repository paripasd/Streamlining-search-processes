{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nlet _Symbol$toStringTag;\nimport { statSync, createReadStream, promises as fs } from 'node:fs';\nimport { basename } from 'node:path';\nimport DOMException from 'node-domexception';\nimport File from './file.js';\nimport Blob from './index.js';\nconst {\n  stat\n} = fs;\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type);\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type));\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type));\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type);\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], {\n  type\n});\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), {\n  type,\n  lastModified: stat.mtimeMs\n});\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nvar _path = /*#__PURE__*/new WeakMap();\nvar _start = /*#__PURE__*/new WeakMap();\n_Symbol$toStringTag = Symbol.toStringTag;\nclass BlobDataItem {\n  constructor(options) {\n    _classPrivateFieldInitSpec(this, _path, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _start, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _path, options.path);\n    _classPrivateFieldSet(this, _start, options.start);\n    this.size = options.size;\n    this.lastModified = options.lastModified;\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice(start, end) {\n    return new BlobDataItem({\n      path: _classPrivateFieldGet(this, _path),\n      lastModified: this.lastModified,\n      size: end - start,\n      start: _classPrivateFieldGet(this, _start) + start\n    });\n  }\n  async *stream() {\n    const {\n      mtimeMs\n    } = await stat(_classPrivateFieldGet(this, _path));\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError');\n    }\n    yield* createReadStream(_classPrivateFieldGet(this, _path), {\n      start: _classPrivateFieldGet(this, _start),\n      end: _classPrivateFieldGet(this, _start) + this.size - 1\n    });\n  }\n  get [_Symbol$toStringTag]() {\n    return 'Blob';\n  }\n}\nexport default blobFromSync;\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync };","map":{"version":3,"names":["statSync","createReadStream","promises","fs","basename","DOMException","File","Blob","stat","blobFromSync","path","type","fromBlob","blobFrom","then","fileFrom","fromFile","fileFromSync","BlobDataItem","size","lastModified","mtimeMs","start","_path","WeakMap","_start","_Symbol$toStringTag","Symbol","toStringTag","constructor","options","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","slice","end","_classPrivateFieldGet","stream"],"sources":["/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/fetch-blob/from.js"],"sourcesContent":["import { statSync, createReadStream, promises as fs } from 'node:fs'\nimport { basename } from 'node:path'\nimport DOMException from 'node-domexception'\n\nimport File from './file.js'\nimport Blob from './index.js'\n\nconst { stat } = fs\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst blobFromSync = (path, type) => fromBlob(statSync(path), path, type)\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<Blob>}\n */\nconst blobFrom = (path, type) => stat(path).then(stat => fromBlob(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n * @returns {Promise<File>}\n */\nconst fileFrom = (path, type) => stat(path).then(stat => fromFile(stat, path, type))\n\n/**\n * @param {string} path filepath on the disk\n * @param {string} [type] mimetype to use\n */\nconst fileFromSync = (path, type) => fromFile(statSync(path), path, type)\n\n// @ts-ignore\nconst fromBlob = (stat, path, type = '') => new Blob([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], { type })\n\n// @ts-ignore\nconst fromFile = (stat, path, type = '') => new File([new BlobDataItem({\n  path,\n  size: stat.size,\n  lastModified: stat.mtimeMs,\n  start: 0\n})], basename(path), { type, lastModified: stat.mtimeMs })\n\n/**\n * This is a blob backed up by a file on the disk\n * with minium requirement. Its wrapped around a Blob as a blobPart\n * so you have no direct access to this.\n *\n * @private\n */\nclass BlobDataItem {\n  #path\n  #start\n\n  constructor (options) {\n    this.#path = options.path\n    this.#start = options.start\n    this.size = options.size\n    this.lastModified = options.lastModified\n  }\n\n  /**\n   * Slicing arguments is first validated and formatted\n   * to not be out of range by Blob.prototype.slice\n   */\n  slice (start, end) {\n    return new BlobDataItem({\n      path: this.#path,\n      lastModified: this.lastModified,\n      size: end - start,\n      start: this.#start + start\n    })\n  }\n\n  async * stream () {\n    const { mtimeMs } = await stat(this.#path)\n    if (mtimeMs > this.lastModified) {\n      throw new DOMException('The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.', 'NotReadableError')\n    }\n    yield * createReadStream(this.#path, {\n      start: this.#start,\n      end: this.#start + this.size - 1\n    })\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n}\n\nexport default blobFromSync\nexport { File, Blob, blobFrom, blobFromSync, fileFrom, fileFromSync }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}