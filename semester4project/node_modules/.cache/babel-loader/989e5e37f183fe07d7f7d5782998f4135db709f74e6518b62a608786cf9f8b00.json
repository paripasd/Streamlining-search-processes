{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nvar _parts, _type, _size, _endings;\nlet _Symbol$toStringTag, _Symbol$hasInstance;\nimport \"core-js/modules/esnext.typed-array.to-reversed.js\";\nimport \"core-js/modules/esnext.typed-array.to-sorted.js\";\nimport \"core-js/modules/esnext.typed-array.with.js\";\nimport \"core-js/modules/es.array.push.js\";\n/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs';\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function* toIterator(parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield* /** @type {AsyncIterableIterator<Uint8Array>} */part.stream();\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset;\n        const end = part.byteOffset + part.byteLength;\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE);\n          const chunk = part.buffer.slice(position, position + size);\n          position += chunk.byteLength;\n          yield new Uint8Array(chunk);\n        }\n      } else {\n        yield part;\n      }\n      /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0,\n        b = /** @type {Blob} */part;\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));\n        const buffer = await chunk.arrayBuffer();\n        position += buffer.byteLength;\n        yield new Uint8Array(buffer);\n      }\n    }\n  }\n}\nconst _Blob = (_parts = /*#__PURE__*/new WeakMap(), _type = /*#__PURE__*/new WeakMap(), _size = /*#__PURE__*/new WeakMap(), _endings = /*#__PURE__*/new WeakMap(), _Symbol$toStringTag = Symbol.toStringTag, _Symbol$hasInstance = Symbol.hasInstance, class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor(blobParts = [], options = {}) {\n    _classPrivateFieldInitSpec(this, _parts, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: ''\n    });\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: 0\n    });\n    _classPrivateFieldInitSpec(this, _endings, {\n      writable: true,\n      value: 'transparent'\n    });\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.');\n    }\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.');\n    }\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.');\n    }\n    if (options === null) options = {};\n    const encoder = new TextEncoder();\n    for (const element of blobParts) {\n      let part;\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0));\n      } else if (element instanceof Blob) {\n        part = element;\n      } else {\n        part = encoder.encode(`${element}`);\n      }\n      _classPrivateFieldSet(this, _size, _classPrivateFieldGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));\n      _classPrivateFieldGet(this, _parts).push(part);\n    }\n    _classPrivateFieldSet(this, _endings, `${options.endings === undefined ? 'transparent' : options.endings}`);\n    const type = options.type === undefined ? '' : String(options.type);\n    _classPrivateFieldSet(this, _type, /^[\\x20-\\x7E]*$/.test(type) ? type : '');\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type() {\n    return _classPrivateFieldGet(this, _type);\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text() {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder();\n    let str = '';\n    for await (const part of toIterator(_classPrivateFieldGet(this, _parts), false)) {\n      str += decoder.decode(part, {\n        stream: true\n      });\n    }\n    // Remaining\n    str += decoder.decode();\n    return str;\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer() {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size);\n    let offset = 0;\n    for await (const chunk of toIterator(_classPrivateFieldGet(this, _parts), false)) {\n      data.set(chunk, offset);\n      offset += chunk.length;\n    }\n    return data.buffer;\n  }\n  stream() {\n    const it = toIterator(_classPrivateFieldGet(this, _parts), true);\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull(ctrl) {\n        const chunk = await it.next();\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n      },\n      async cancel() {\n        await it.return();\n      }\n    });\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice(start = 0, end = this.size, type = '') {\n    const {\n      size\n    } = this;\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const parts = _classPrivateFieldGet(this, _parts);\n    const blobParts = [];\n    let added = 0;\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break;\n      }\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size;\n        relativeEnd -= size;\n      } else {\n        let chunk;\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.byteLength;\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n          added += chunk.size;\n        }\n        relativeEnd -= size;\n        blobParts.push(chunk);\n        relativeStart = 0; // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], {\n      type: String(type).toLowerCase()\n    });\n    _classPrivateFieldSet(blob, _size, span);\n    _classPrivateFieldSet(blob, _parts, blobParts);\n    return blob;\n  }\n  get [_Symbol$toStringTag]() {\n    return 'Blob';\n  }\n  static [_Symbol$hasInstance](object) {\n    return object && typeof object === 'object' && typeof object.constructor === 'function' && (typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n  }\n});\nObject.defineProperties(_Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob;\nexport default Blob;","map":{"version":3,"names":["POOL_SIZE","toIterator","parts","clone","part","stream","ArrayBuffer","isView","position","byteOffset","end","byteLength","size","Math","min","chunk","buffer","slice","Uint8Array","b","arrayBuffer","_Blob","_parts","WeakMap","_type","_size","_endings","_Symbol$toStringTag","Symbol","toStringTag","_Symbol$hasInstance","hasInstance","Blob","constructor","blobParts","options","_classPrivateFieldInitSpec","writable","value","TypeError","iterator","encoder","TextEncoder","element","encode","_classPrivateFieldSet","_classPrivateFieldGet","push","endings","undefined","type","String","test","text","decoder","TextDecoder","str","decode","data","offset","set","length","it","globalThis","ReadableStream","pull","ctrl","next","done","close","enqueue","cancel","return","start","relativeStart","max","relativeEnd","span","added","subarray","blob","toLowerCase","object","Object","defineProperties","prototype","enumerable"],"sources":["/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/fetch-blob/index.js"],"sourcesContent":["/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs'\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536\n\n/** @param {(Blob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n  for (const part of parts) {\n    if ('stream' in part) {\n      yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()))\n    } else if (ArrayBuffer.isView(part)) {\n      if (clone) {\n        let position = part.byteOffset\n        const end = part.byteOffset + part.byteLength\n        while (position !== end) {\n          const size = Math.min(end - position, POOL_SIZE)\n          const chunk = part.buffer.slice(position, position + size)\n          position += chunk.byteLength\n          yield new Uint8Array(chunk)\n        }\n      } else {\n        yield part\n      }\n    /* c8 ignore next 10 */\n    } else {\n      // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n      let position = 0, b = (/** @type {Blob} */ (part))\n      while (position !== b.size) {\n        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE))\n        const buffer = await chunk.arrayBuffer()\n        position += buffer.byteLength\n        yield new Uint8Array(buffer)\n      }\n    }\n  }\n}\n\nconst _Blob = class Blob {\n  /** @type {Array.<(Blob|Uint8Array)>} */\n  #parts = []\n  #type = ''\n  #size = 0\n  #endings = 'transparent'\n\n  /**\n   * The Blob() constructor returns a new Blob object. The content\n   * of the blob consists of the concatenation of the values given\n   * in the parameter array.\n   *\n   * @param {*} blobParts\n   * @param {{ type?: string, endings?: string }} [options]\n   */\n  constructor (blobParts = [], options = {}) {\n    if (typeof blobParts !== 'object' || blobParts === null) {\n      throw new TypeError('Failed to construct \\'Blob\\': The provided value cannot be converted to a sequence.')\n    }\n\n    if (typeof blobParts[Symbol.iterator] !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': The object must have a callable @@iterator property.')\n    }\n\n    if (typeof options !== 'object' && typeof options !== 'function') {\n      throw new TypeError('Failed to construct \\'Blob\\': parameter 2 cannot convert to dictionary.')\n    }\n\n    if (options === null) options = {}\n\n    const encoder = new TextEncoder()\n    for (const element of blobParts) {\n      let part\n      if (ArrayBuffer.isView(element)) {\n        part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength))\n      } else if (element instanceof ArrayBuffer) {\n        part = new Uint8Array(element.slice(0))\n      } else if (element instanceof Blob) {\n        part = element\n      } else {\n        part = encoder.encode(`${element}`)\n      }\n\n      this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size\n      this.#parts.push(part)\n    }\n\n    this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`\n    const type = options.type === undefined ? '' : String(options.type)\n    this.#type = /^[\\x20-\\x7E]*$/.test(type) ? type : ''\n  }\n\n  /**\n   * The Blob interface's size property returns the\n   * size of the Blob in bytes.\n   */\n  get size () {\n    return this.#size\n  }\n\n  /**\n   * The type property of a Blob object returns the MIME type of the file.\n   */\n  get type () {\n    return this.#type\n  }\n\n  /**\n   * The text() method in the Blob interface returns a Promise\n   * that resolves with a string containing the contents of\n   * the blob, interpreted as UTF-8.\n   *\n   * @return {Promise<string>}\n   */\n  async text () {\n    // More optimized than using this.arrayBuffer()\n    // that requires twice as much ram\n    const decoder = new TextDecoder()\n    let str = ''\n    for await (const part of toIterator(this.#parts, false)) {\n      str += decoder.decode(part, { stream: true })\n    }\n    // Remaining\n    str += decoder.decode()\n    return str\n  }\n\n  /**\n   * The arrayBuffer() method in the Blob interface returns a\n   * Promise that resolves with the contents of the blob as\n   * binary data contained in an ArrayBuffer.\n   *\n   * @return {Promise<ArrayBuffer>}\n   */\n  async arrayBuffer () {\n    // Easier way... Just a unnecessary overhead\n    // const view = new Uint8Array(this.size);\n    // await this.stream().getReader({mode: 'byob'}).read(view);\n    // return view.buffer;\n\n    const data = new Uint8Array(this.size)\n    let offset = 0\n    for await (const chunk of toIterator(this.#parts, false)) {\n      data.set(chunk, offset)\n      offset += chunk.length\n    }\n\n    return data.buffer\n  }\n\n  stream () {\n    const it = toIterator(this.#parts, true)\n\n    return new globalThis.ReadableStream({\n      // @ts-ignore\n      type: 'bytes',\n      async pull (ctrl) {\n        const chunk = await it.next()\n        chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value)\n      },\n\n      async cancel () {\n        await it.return()\n      }\n    })\n  }\n\n  /**\n   * The Blob interface's slice() method creates and returns a\n   * new Blob object which contains data from a subset of the\n   * blob on which it's called.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @param {string} [type]\n   */\n  slice (start = 0, end = this.size, type = '') {\n    const { size } = this\n\n    let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size)\n    let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size)\n\n    const span = Math.max(relativeEnd - relativeStart, 0)\n    const parts = this.#parts\n    const blobParts = []\n    let added = 0\n\n    for (const part of parts) {\n      // don't add the overflow to new blobParts\n      if (added >= span) {\n        break\n      }\n\n      const size = ArrayBuffer.isView(part) ? part.byteLength : part.size\n      if (relativeStart && size <= relativeStart) {\n        // Skip the beginning and change the relative\n        // start & end position as we skip the unwanted parts\n        relativeStart -= size\n        relativeEnd -= size\n      } else {\n        let chunk\n        if (ArrayBuffer.isView(part)) {\n          chunk = part.subarray(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.byteLength\n        } else {\n          chunk = part.slice(relativeStart, Math.min(size, relativeEnd))\n          added += chunk.size\n        }\n        relativeEnd -= size\n        blobParts.push(chunk)\n        relativeStart = 0 // All next sequential parts should start at 0\n      }\n    }\n\n    const blob = new Blob([], { type: String(type).toLowerCase() })\n    blob.#size = span\n    blob.#parts = blobParts\n\n    return blob\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Blob'\n  }\n\n  static [Symbol.hasInstance] (object) {\n    return (\n      object &&\n      typeof object === 'object' &&\n      typeof object.constructor === 'function' &&\n      (\n        typeof object.stream === 'function' ||\n        typeof object.arrayBuffer === 'function'\n      ) &&\n      /^(Blob|File)$/.test(object[Symbol.toStringTag])\n    )\n  }\n}\n\nObject.defineProperties(_Blob.prototype, {\n  size: { enumerable: true },\n  type: { enumerable: true },\n  slice: { enumerable: true }\n})\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob\nexport default Blob\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}