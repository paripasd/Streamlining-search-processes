{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport { types } from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ? http.validateHeaderName : name => {\n  if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n    const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_HTTP_TOKEN'\n    });\n    throw error;\n  }\n};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ? http.validateHeaderValue : (name, value) => {\n  if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n    const error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n    Object.defineProperty(error, 'code', {\n      value: 'ERR_INVALID_CHAR'\n    });\n    throw error;\n  }\n};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n  /**\n   * Headers class\n   *\n   * @constructor\n   * @param {HeadersInit} [init] - Response headers\n   */\n  constructor(init) {\n    // Validate and normalize init object in [name, value(s)][]\n    /** @type {string[][]} */\n    let result = [];\n    if (init instanceof Headers) {\n      const raw = init.raw();\n      for (const [name, values] of Object.entries(raw)) {\n        result.push(...values.map(value => [name, value]));\n      }\n    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq\n      // No op\n    } else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n      const method = init[Symbol.iterator];\n      // eslint-disable-next-line no-eq-null, eqeqeq\n      if (method == null) {\n        // Record<ByteString, ByteString>\n        result.push(...Object.entries(init));\n      } else {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        }\n\n        // Sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        result = [...init].map(pair => {\n          if (typeof pair !== 'object' || types.isBoxedPrimitive(pair)) {\n            throw new TypeError('Each header pair must be an iterable object');\n          }\n          return [...pair];\n        }).map(pair => {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n          return [...pair];\n        });\n      }\n    } else {\n      throw new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n    }\n\n    // Validate and lowercase\n    result = result.length > 0 ? result.map(([name, value]) => {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return [String(name).toLowerCase(), String(value)];\n    }) : undefined;\n    super(result);\n\n    // Returning a Proxy that will lowercase key names, validate parameters and sort keys\n    // eslint-disable-next-line no-constructor-return\n    return new Proxy(this, {\n      get(target, p, receiver) {\n        switch (p) {\n          case 'append':\n          case 'set':\n            return (name, value) => {\n              validateHeaderName(name);\n              validateHeaderValue(name, String(value));\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));\n            };\n          case 'delete':\n          case 'has':\n          case 'getAll':\n            return name => {\n              validateHeaderName(name);\n              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());\n            };\n          case 'keys':\n            return () => {\n              target.sort();\n              return new Set(URLSearchParams.prototype.keys.call(target)).keys();\n            };\n          default:\n            return Reflect.get(target, p, receiver);\n        }\n      }\n    });\n    /* c8 ignore next */\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  toString() {\n    return Object.prototype.toString.call(this);\n  }\n  get(name) {\n    const values = this.getAll(name);\n    if (values.length === 0) {\n      return null;\n    }\n    let value = values.join(', ');\n    if (/^content-encoding$/i.test(name)) {\n      value = value.toLowerCase();\n    }\n    return value;\n  }\n  forEach(callback, thisArg = undefined) {\n    for (const name of this.keys()) {\n      Reflect.apply(callback, thisArg, [this.get(name), name, this]);\n    }\n  }\n  *values() {\n    for (const name of this.keys()) {\n      yield this.get(name);\n    }\n  }\n\n  /**\n   * @type {() => IterableIterator<[string, string]>}\n   */\n  *entries() {\n    for (const name of this.keys()) {\n      yield [name, this.get(name)];\n    }\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * Node-fetch non-spec method\n   * returning all headers and their values as array\n   * @returns {Record<string, string[]>}\n   */\n  raw() {\n    return [...this.keys()].reduce((result, key) => {\n      result[key] = this.getAll(key);\n      return result;\n    }, {});\n  }\n\n  /**\n   * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n   */\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return [...this.keys()].reduce((result, key) => {\n      const values = this.getAll(key);\n      // Http.request() only supports string as Host header.\n      // This hack makes specifying custom Host header possible.\n      if (key === 'host') {\n        result[key] = values[0];\n      } else {\n        result[key] = values.length > 1 ? values : values[0];\n      }\n      return result;\n    }, {});\n  }\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n  result[property] = {\n    enumerable: true\n  };\n  return result;\n}, {}));\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n  return new Headers(headers\n  // Split into pairs\n  .reduce((result, value, index, array) => {\n    if (index % 2 === 0) {\n      result.push(array.slice(index, index + 2));\n    }\n    return result;\n  }, []).filter(([name, value]) => {\n    try {\n      validateHeaderName(name);\n      validateHeaderValue(name, String(value));\n      return true;\n    } catch {\n      return false;\n    }\n  }));\n}","map":{"version":3,"names":["types","http","validateHeaderName","name","test","error","TypeError","Object","defineProperty","value","validateHeaderValue","Headers","URLSearchParams","constructor","init","result","raw","values","entries","push","map","isBoxedPrimitive","method","Symbol","iterator","pair","length","String","toLowerCase","undefined","Proxy","get","target","p","receiver","prototype","call","sort","Set","keys","Reflect","toStringTag","toString","getAll","join","forEach","callback","thisArg","apply","reduce","key","for","defineProperties","property","enumerable","fromRawHeaders","headers","index","array","slice","filter"],"sources":["/Users/gaborkiss/Documents/GitHub/semester4project/semester4project/node_modules/node-fetch/src/headers.js"],"sourcesContent":["/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'node:util';\nimport http from 'node:http';\n\n/* c8 ignore next 9 */\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/* c8 ignore next 9 */\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t/* c8 ignore next */\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}