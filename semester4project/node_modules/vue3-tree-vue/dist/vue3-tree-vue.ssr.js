'use strict';var vue=require('vue');function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}var cascadeStateToDescendants = function cascadeStateToDescendants(item, state) {
  var _item$children;

  (_item$children = item.children) === null || _item$children === void 0 ? void 0 : _item$children.forEach(function (child) {
    child.checkedStatus = item.checkedStatus;
    state.emitItemCheckedChange(child);
    cascadeStateToDescendants(child, state);
  });
};
var notifyParentOfSelection = function notifyParentOfSelection(child, state) {
  var _parent$children, _parent$children2, _parent$children3, _parent$children4;

  if (!child) return;
  var parent = state.getParent(child.id);
  if (!parent) return;
  var isEveryChildChecked = (_parent$children = parent.children) === null || _parent$children === void 0 ? void 0 : _parent$children.every(function (child) {
    return child.checkedStatus == 'true';
  });
  var hasIntermediate = (_parent$children2 = parent.children) === null || _parent$children2 === void 0 ? void 0 : _parent$children2.some(function (child) {
    return child.checkedStatus == 'indeterminate';
  });
  var hasAnUncheckedChild = (_parent$children3 = parent.children) === null || _parent$children3 === void 0 ? void 0 : _parent$children3.some(function (child) {
    return child.checkedStatus == 'false' || !child.checkedStatus;
  });
  var hasACheckedChild = (_parent$children4 = parent.children) === null || _parent$children4 === void 0 ? void 0 : _parent$children4.some(function (child) {
    return child.checkedStatus == 'true';
  });

  if (isEveryChildChecked) {
    parent.checkedStatus = 'true';
  } else if (hasIntermediate || hasAnUncheckedChild && hasACheckedChild) {
    parent.checkedStatus = 'indeterminate';
  } else {
    parent.checkedStatus = 'false';
  }

  state.emitItemCheckedChange(parent);
  notifyParentOfSelection(parent, state);
};var script$1 = vue.defineComponent({
  inheritAttrs: true,
  props: {
    item: {
      type: Object,
      required: true
    },
    isCheckable: {
      type: Boolean
    },
    canRename: {
      type: Boolean
    },
    selectedItem: {
      type: Object
    },
    treeState: {
      type: Object
    }
  },
  emits: ["on-rename", "onContextMenu"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    var checkbox = vue.ref();
    var isSelected = vue.computed(function () {
      var _props$selectedItem;

      return ((_props$selectedItem = props.selectedItem) === null || _props$selectedItem === void 0 ? void 0 : _props$selectedItem.id) == props.item.id;
    });
    var parent = vue.computed(function () {
      return attrs.parent;
    });
    vue.onMounted(function () {
      var _props$treeState, _props$treeState2;

      (_props$treeState = props.treeState) === null || _props$treeState === void 0 ? void 0 : _props$treeState.trackNode(props.item, parent.value);

      if ((_props$treeState2 = props.treeState) !== null && _props$treeState2 !== void 0 && _props$treeState2.isNodeExpanded(props.item.id, props.item.type)) {
        toggleExpand();
      }
    });
    vue.onUnmounted(function () {
      var _props$treeState3;

      return (_props$treeState3 = props.treeState) === null || _props$treeState3 === void 0 ? void 0 : _props$treeState3.untrackNode(props.item);
    });

    var updateCheckState = function updateCheckState() {
      var _checkbox$value;

      props.item.checkedStatus = ((_checkbox$value = checkbox.value) === null || _checkbox$value === void 0 ? void 0 : _checkbox$value.checked) == true ? 'true' : 'false';
      props.treeState.emitItemCheckedChange(props.item);
      notifyParentOfSelection(props.item, props.treeState);
      cascadeStateToDescendants(props.item, props.treeState);
    };

    vue.watch(function () {
      return props.item.checkedStatus;
    }, function () {
      if (props.item.checkedStatus == 'indeterminate') {
        checkbox.value.indeterminate = true;
      } else {
        checkbox.value.indeterminate = false;
        checkbox.value.checked = props.item.checkedStatus == 'true' ? true : false;
      }
    });
    var isRenaming = vue.ref(false);
    var renameBox = vue.ref();

    var beginRenaming = function beginRenaming() {
      if (!props.canRename) return;
      isRenaming.value = true;
      vue.nextTick().then(function () {
        var _renameBox$value;

        return (_renameBox$value = renameBox.value) === null || _renameBox$value === void 0 ? void 0 : _renameBox$value.focus();
      });
    };

    var finishRenaming = function finishRenaming() {
      // v-on:blur and key(enter) can cause this to fire twice.
      // this check protects against that.
      if (!isRenaming) return;
      emit("on-rename", props.item);
    };

    var chevron = vue.ref();

    var toggleExpand = function toggleExpand() {
      var _chevron$value, _document$getElementB;

      (_chevron$value = chevron.value) === null || _chevron$value === void 0 ? void 0 : _chevron$value.classList.toggle("rotate-90");
      var element = (_document$getElementB = document.getElementById(props.item.id)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.getElementsByClassName('node-child');
      if (!element || !element[0]) return;
      element[0].classList.toggle('hide');
    };

    return {
      toggleExpand: toggleExpand,
      chevron: chevron,
      isSelected: isSelected,
      updateCheckState: updateCheckState,
      isRenaming: isRenaming,
      beginRenaming: beginRenaming,
      finishRenaming: finishRenaming,
      parent: parent,
      checkbox: checkbox
    };
  }
});var _hoisted_1$1 = {
  key: 0,
  class: "horizontal-dashes"
};
var _hoisted_2$1 = {
  key: 0,
  style: {
    "display": "flex"
  }
};
var _hoisted_3 = {
  class: "d-flex",
  style: {
    "margin-left": "0.4em",
    "margin-right": "0.4em"
  }
};
var _hoisted_4 = {
  key: 0,
  for: "checkbox"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: "d-flex align-items-center",
    onContextmenu: _cache[8] || (_cache[8] = vue.withModifiers(function ($event) {
      return _ctx.$emit('onContextMenu', {
        item: _ctx.item,
        event: $event
      });
    }, ["prevent"]))
  }, [_ctx.$attrs.isNested ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1)) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
    class: vue.normalizeClass(["chevron-right", {
      'hide-chevron': !_ctx.item.children || _ctx.item.children.length < 1
    }]),
    ref: "chevron",
    onClick: _cache[0] || (_cache[0] = function ($event) {
      return _ctx.toggleExpand();
    })
  }, null, 2), vue.createElementVNode("div", {
    class: vue.normalizeClass(["pointer", {
      'selected-tree-item': !_ctx.isCheckable && _ctx.isSelected
    }]),
    style: {
      "width": "100%"
    }
  }, [!_ctx.isRenaming ? (vue.openBlock(), vue.createElementBlock("div", {
    key: 0,
    onDblclick: _cache[4] || (_cache[4] = function () {
      return _ctx.beginRenaming && _ctx.beginRenaming.apply(_ctx, arguments);
    })
  }, [_ctx.isCheckable ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1, [vue.createElementVNode("input", {
    onContextmenu: _cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["prevent"])),
    onChange: _cache[2] || (_cache[2] = function () {
      return _ctx.updateCheckState && _ctx.updateCheckState.apply(_ctx, arguments);
    }),
    type: "checkbox",
    ref: "checkbox"
  }, null, 544), vue.createElementVNode("div", _hoisted_3, [vue.renderSlot(_ctx.$slots, "icon"), vue.renderSlot(_ctx.$slots, "prepend")]), !_ctx.isRenaming ? (vue.openBlock(), vue.createElementBlock("label", _hoisted_4, vue.toDisplayString(_ctx.item.name), 1)) : vue.createCommentVNode("", true)])) : (vue.openBlock(), vue.createElementBlock("div", {
    key: 1,
    class: "d-flex",
    onClick: _cache[3] || (_cache[3] = function ($event) {
      var _ctx$treeState;

      return (_ctx$treeState = _ctx.treeState) === null || _ctx$treeState === void 0 ? void 0 : _ctx$treeState.emitItemSelected(_ctx.item);
    })
  }, [vue.renderSlot(_ctx.$slots, "icon"), vue.renderSlot(_ctx.$slots, "prepend"), vue.createElementVNode("span", null, vue.toDisplayString(_ctx.item.name), 1)]))], 32)) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
    key: 1,
    ref: "rename-box",
    "onUpdate:modelValue": _cache[5] || (_cache[5] = function ($event) {
      return _ctx.item.name = $event;
    }),
    onKeyup: _cache[6] || (_cache[6] = vue.withKeys(function () {
      return _ctx.finishRenaming && _ctx.finishRenaming.apply(_ctx, arguments);
    }, ["enter"])),
    onBlur: _cache[7] || (_cache[7] = function () {
      return _ctx.finishRenaming && _ctx.finishRenaming.apply(_ctx, arguments);
    })
  }, null, 544)), [[vue.vModelText, _ctx.item.name]])], 2)], 32);
}script$1.render = render$1;function useTreeViewItemMouseActions() {
  var addHoverClass = function addHoverClass(event) {
    var target = event.currentTarget;

    if (target) {
      target.classList.add('drag-over');
    }
  };

  var removeHoverClass = function removeHoverClass(event) {
    var target = event.currentTarget;

    if (target) {
      target.classList.remove('drag-over');
    }
  };

  var onDragNode = function onDragNode(item, event) {
    if (event.dataTransfer) {
      event.dataTransfer.setData('text/plain', JSON.stringify(item));
    }
  };

  var onDropNode = function onDropNode(dropHost, event, isDropValid) {
    if (event.dataTransfer) {
      var droppedNode = JSON.parse(event.dataTransfer.getData('text/plain'));
      removeHoverClass(event);

      if (droppedNode.id === dropHost.id) {
        return;
      }

      if (!isDropValid(droppedNode, dropHost)) return;
    }
  };

  return {
    addHoverClass: addHoverClass,
    removeHoverClass: removeHoverClass,
    onDragNode: onDragNode,
    onDropNode: onDropNode
  };
}/**
 * Initialises the root state of a tree.
 * @param selectedItem A preselected item
 * @param onItemSelected Callback for itemselected
 * @param checkedItems An array of prechecked items
 * @param onItemsChecked Callback for itemChecked
 * @param isNodeExpanded A callback to verify if node is preset to expanded
 * @param itemSelectedEventHandler A callback when an item is selected.
 * @param itemSelectedEventHandler A callback when an item is checked.
 * @returns 
 */
function useGraph(selectedItem, onItemSelected, checkedItems, onItemsChecked, isNodeExpanded, itemSelectedEventHandler, itemCheckedEventHandler) {
  var childParentLookUp = {};

  var getParent = function getParent(childId) {
    return childParentLookUp[childId];
  };

  var trackNode = function trackNode(node, parentNode) {
    return childParentLookUp[node.id] = parentNode;
  };

  var untrackNode = function untrackNode(node) {
    return delete childParentLookUp[node.id];
  };

  var checkedItemsLookup = {};
  checkedItems === null || checkedItems === void 0 ? void 0 : checkedItems.forEach(function (node) {
    return checkedItemsLookup[node.id] = node;
  });

  var emitItemSelected = function emitItemSelected(node) {
    itemSelectedEventHandler({
      item: node,
      change: 'selected'
    });
    if (node === selectedItem) return;
    selectedItem = node;
    onItemSelected(node);
  };

  var emitItemCheckedChange = function emitItemCheckedChange(node) {
    itemCheckedEventHandler({
      item: node,
      change: node.checkedStatus
    });
    if (node.checkedStatus == 'true') checkedItemsLookup[node.id] = node;else delete checkedItemsLookup[node.id];
    onItemsChecked(Object.values(checkedItemsLookup));
  };

  return {
    getParent: getParent,
    trackNode: trackNode,
    untrackNode: untrackNode,
    emitItemCheckedChange: emitItemCheckedChange,
    emitItemSelected: emitItemSelected,
    isNodeExpanded: isNodeExpanded
  };
}var script = vue.defineComponent({
  name: 'tree-view',
  props: {
    items: {
      type: Array,
      required: true,
      default: function _default() {
        return [];
      }
    },
    selectedItem: {
      type: Object
    },
    checkedItems: {
      type: Array
    },
    isCheckable: {
      type: Boolean
    },
    hideGuideLines: {
      type: Boolean,
      default: false
    },
    onDropValidator: {
      type: Function,
      default: function _default() {
      }
    },
    treeState: {
      type: Object
    },
    expandedTypes: {
      type: Object,
      default: function _default() {
        return [];
      }
    },
    expandedIds: {
      type: Object,
      default: function _default() {
        return [];
      }
    },
    expandAll: {
      type: Boolean,
      default: false
    }
  },
  components: {
    'treeview-item': script$1
  },
  emits: ['update:selectedItem', 'update:checkedItems', 'onContextMenu', 'onSelect', 'onCheck'],
  setup: function setup(props, _ref) {
    var emit = _ref.emit,
        attrs = _ref.attrs;
    var parent = vue.computed(function () {
      return attrs.parent;
    });
    var treeState = vue.ref();
    var expandedKeys = new Set([].concat(_toConsumableArray(props.expandedTypes), _toConsumableArray(props.expandedIds))); // Create a tree state object for only root nodes.

    if (props.treeState != null) {
      treeState.value = props.treeState;
    } else {
      treeState.value = useGraph(props.selectedItem, function (selectedItem) {
        return emit('update:selectedItem', selectedItem);
      }, props.checkedItems, function (checkedItems) {
        return emit('update:checkedItems', checkedItems);
      }, function (id, type) {
        return expandedKeys.has(id) || expandedKeys.has(type) || props.expandAll;
      }, function (eventArguments) {
        return emit('onSelect', eventArguments);
      }, function (eventArguments) {
        return emit('onCheck', eventArguments);
      });
    }

    return _objectSpread2(_objectSpread2({}, useTreeViewItemMouseActions()), {}, {
      parent: parent,
      treeState: treeState
    });
  }
});var _hoisted_1 = {
  id: "explorer",
  class: "explorer tree-item-node-parent"
};
var _hoisted_2 = ["id", "onDragstart", "onDrop"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_treeview_item = vue.resolveComponent("treeview-item");

  var _component_tree_view = vue.resolveComponent("tree-view");

  return vue.openBlock(), vue.createElementBlock("ul", _hoisted_1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (treeViewItem) {
    return vue.openBlock(), vue.createElementBlock("li", {
      key: treeViewItem.id,
      id: treeViewItem.id,
      draggable: "",
      onDragover: [_cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["stop", "prevent"])), _cache[3] || (_cache[3] = vue.withModifiers(function () {
        return _ctx.addHoverClass && _ctx.addHoverClass.apply(_ctx, arguments);
      }, ["stop"]))],
      onDragenter: _cache[2] || (_cache[2] = vue.withModifiers(function () {}, ["stop", "prevent"])),
      onDragstart: vue.withModifiers(function ($event) {
        return _ctx.onDragNode(treeViewItem, $event);
      }, ["stop"]),
      onDrop: vue.withModifiers(function ($event) {
        return _ctx.onDropNode(treeViewItem, $event, _ctx.onDropValidator);
      }, ["prevent", "stop"]),
      class: "tree-item-node",
      onDragleave: _cache[4] || (_cache[4] = vue.withModifiers(function () {
        return _ctx.removeHoverClass && _ctx.removeHoverClass.apply(_ctx, arguments);
      }, ["stop"]))
    }, [vue.createVNode(_component_treeview_item, {
      class: "pointer tree-view-item",
      item: treeViewItem,
      parent: _ctx.parent,
      isCheckable: _ctx.isCheckable,
      selectedItem: _ctx.selectedItem,
      treeState: _ctx.treeState,
      onContextmenu: vue.withModifiers(function ($event) {
        return _ctx.$emit('onContextMenu', {
          item: treeViewItem,
          event: $event
        });
      }, ["prevent"])
    }, {
      icon: vue.withCtx(function () {
        return [vue.renderSlot(_ctx.$slots, "item-prepend-icon", vue.normalizeProps(vue.guardReactiveProps(treeViewItem)))];
      }),
      prepend: vue.withCtx(function () {
        return [vue.renderSlot(_ctx.$slots, "item-prepend", vue.normalizeProps(vue.guardReactiveProps(treeViewItem)))];
      }),
      _: 2
    }, 1032, ["item", "parent", "isCheckable", "selectedItem", "treeState", "onContextmenu"]), treeViewItem.children && treeViewItem.children.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(["node-child hide", {
        'hide-guidelines': _ctx.hideGuideLines
      }])
    }, [vue.createVNode(_component_tree_view, {
      items: treeViewItem.children,
      hideGuideLines: _ctx.hideGuideLines,
      isNested: true,
      parent: treeViewItem,
      selectedItem: _ctx.selectedItem,
      checkedItems: _ctx.checkedItems,
      treeState: _ctx.treeState,
      isCheckable: _ctx.isCheckable,
      onOnContextMenu: _cache[0] || (_cache[0] = function ($event) {
        return _ctx.$emit('onContextMenu', $event);
      })
    }, vue.createSlots({
      _: 2
    }, [vue.renderList(_ctx.$slots, function (_, slot) {
      return {
        name: slot,
        fn: vue.withCtx(function (props) {
          return [vue.renderSlot(_ctx.$slots, slot, vue.normalizeProps(vue.guardReactiveProps(props)))];
        })
      };
    })]), 1032, ["items", "hideGuideLines", "parent", "selectedItem", "checkedItems", "treeState", "isCheckable"])], 2)) : vue.createCommentVNode("", true)], 40, _hoisted_2);
  }), 128))]);
}script.render = render;var component = (function () {
  var installable = script;

  installable.install = function (app) {
    app.component('vue3-tree-vue', installable);
  };

  return installable;
})();var namedExports=/*#__PURE__*/Object.freeze({__proto__:null,'default':component});// only expose one global var, with named exports exposed as properties of
// that global var (eg. plugin.namedExport)

Object.entries(namedExports).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      exportName = _ref2[0],
      exported = _ref2[1];

  if (exportName !== 'default') component[exportName] = exported;
});module.exports=component;